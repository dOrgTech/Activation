pragma solidity ^0.5.11;

import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";
import "@openzeppelin/upgrades/contrats/Initializable.sol";
import "../VotingCredits/VotingCredits.sol";
import "./lib/IProposalExecute.sol";
import "./lib/IVotingMachine";
import "./lib/IVotingMachineCallbacks.sol";

contract AbsoluteMajority is IVotingMachine, Initializable {
  using SafeMath for uint;

  struct Parameters {
    uint256 percReq; // how many percentages required for the proposal to be passed
    address voteOnBehalf; //if this address is set so only this address is allowed
                          // to vote of behalf of someone else.
  }

  struct Voter {
    uint256 vote; // 0 - 'abstain'
    uint256 reputation; // amount of voter's reputation
  }

  struct Proposal {
    bool open; // voting open flag
    uint256 numOfChoices;
    uint256 totalVotes;
    mapping(uint=>uint) votes;
    mapping(address=>Voter) voters;
  }

  event AVVoteProposal(bytes32 indexed _proposalId, bool _isProxyVote);

  Parameters public parameters;
  mapping(bytes32=>Proposal) public proposals; // Mapping from the ID of the proposal to the proposal itself.
  address public organization;
  address public callbacks;
  address public authorizedToPropose;

  uint256 public constant MAX_NUM_OF_CHOICES = 10;
  uint256 public proposalsCnt; // Total amount of proposals

  /**
    * @dev Check that the proposal is votable (open and not executed yet)
    */
  modifier votable(
    bytes32 _proposalId
  )
  {
    require(proposals[_proposalId].open, "proposal is not votable");
    _;
  }

  /**
    * @dev initialize
    * @param _percReq requre percentage for absolure majority
    * @param _voteOnBehalf enable vote on behalf
    * @param _organization organization
    * @param _callbacks should fulfill voting callbacks interface.
    * @param _authorizedToPropose only this address allow to propose (unless it is zero)
    */
  function initialize(
    uint256 _percReq,
    address _voteOnBehalf,
    address _organization,
    address _callbacks,
    address _authorizedToPropose
  )
  external
  initializer
  {
    require(_percReq <= 100 && _percReq > 0, "wrong percReq");
    parameters = Parameters({
      percReq: _percReq,
      voteOnBehalf: _voteOnBehalf
    });
    organization = _organization;
    callbacks = _callbacks;
    authorizedToPropose = _authorizedToPropose;
  }

  /**
    * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
    * generated by calculating keccak256 of a incremented counter.
    * @param _numOfChoices number of voting choices
    * @return proposal's id.
    */
  function propose(
    uint256 _numOfChoices,
    address,
  )
    external
    returns(bytes32)
  {
    require(
      (authorizedToPropose == address(0)) || (msg.sender == authorizedToPropose),
      "msg.sender not authorized to propose"
    );

    // Check valid params and number of choices:
    require(
      parameters.percReq > 0,
      "no initialized been called"
    );
    require(
      _numOfChoices > 0 && _numOfChoices <= MAX_NUM_OF_CHOICES,
      "numOfChoices out of range"
    );

    // Generate a unique ID:
    bytes32 proposalId = keccak256(abi.encodePacked(this, proposalsCnt));
    proposalsCnt = proposalsCnt.add(1);
    // Open proposal:
    Proposal memory proposal;
    proposal.numOfChoices = _numOfChoices;
    proposal.open = true;
    proposals[proposalId] = proposal;
    emit NewProposal(proposalId, organization, _numOfChoices, msg.sender);
    return proposalId;
  }

  /**
    * @dev voting function
    * @param _proposalId id of the proposal
    * @param _vote a value between 0 to and the proposal number of choices.
    * @param _amount the reputation amount to vote with . if _amount == 0 it will use all voter reputation.
    * @param _voter voter address
    * @return bool true - the proposal has been executed
    *              false - otherwise.
    */
  function vote(
    bytes32 _proposalId,
    uint256 _vote,
    uint256 _amount,
    address _voter
  )
  external
  votable(_proposalId)
  returns(bool)
  {
    Parameters memory params = parameters;
    address voter;
    if (params.voteOnBehalf != address(0)) {
      require(msg.sender == parameters.voteOnBehalf, "msg.sender is not authorized to vote");
      voter = _voter;
    } else {
      voter = msg.sender;
    }
    return internalVote(_proposalId, voter, _vote, _amount);
  }

  /**
    * @dev Cancel the vote of the msg.sender: subtract the reputation amount from the votes
    * and delete the voter from the proposal struct
    * @param _proposalId id of the proposal
    */
  function cancelVote(
    bytes32 _proposalId
  )
  external
  votable(_proposalId)
  {
    cancelVoteInternal(_proposalId, msg.sender);
  }

  /**
    * @dev execute check if the proposal has been decided, and if so, execute the proposal
    * @param _proposalId the id of the proposal
    * @return bool true - the proposal has been executed
    *              false - otherwise.
    */
  function execute(
    bytes32 _proposalId
  )
  external
  votable(_proposalId)
  returns(bool)
  {
    return _execute(_proposalId);
  }

  /**
    * @dev getNumberOfChoices returns the number of choices possible in this proposal
    * excluding the abstain vote (0)
    * @param _proposalId the ID of the proposal
    * @return uint256 that contains number of choices
    */
  function getNumberOfChoices(
    bytes32 _proposalId
  )
  external
  view
  returns(uint256)
  {
    return proposals[_proposalId].numOfChoices;
  }

  /**
    * @dev voteInfo returns the vote and the amount of reputation of the user committed to this proposal
    * @param _proposalId the ID of the proposal
    * @param _voter the address of the voter
    * @return uint256 vote - the voters vote
    *        uint256 reputation - amount of reputation committed by _voter to _proposalId
    */
  function voteInfo(
    bytes32 _proposalId,
    address _voter
  )
  external
  view
  returns(uint, uint)
  {
    Voter memory voter = proposals[_proposalId].voters[_voter];
    return (voter.vote, voter.reputation);
  }

  /**
    * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
    * @param _proposalId the ID of the proposal
    * @param _choice the index in the
    * @return voted reputation for the given choice
    */
  function voteStatus(
    bytes32 _proposalId,
    uint256 _choice
  )
  external
  view
  returns(uint256)
  {
    return proposals[_proposalId].votes[_choice];
  }

  /**
    * @dev isVotable check if the proposal is votable
    * @param _proposalId the ID of the proposal
    * @return bool true or false
    */
  function isVotable(
    bytes32 _proposalId
  )
  external
  view
  returns(bool)
  {
    return  proposals[_proposalId].open;
  }

  /**
    * @dev isAbstainAllow returns if the voting machine allow abstain (0)
    * @return bool true or false
    */
  function isAbstainAllow()
  external
  pure
  returns(bool)
  {
    return true;
  }

  /**
    * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
    * @return min - minimum number of choices
              max - maximum number of choices
    */
  function getAllowedRangeOfChoices()
  external
  pure
  returns(uint256 min, uint256 max)
  {
    return (0, MAX_NUM_OF_CHOICES);
  }

  function cancelVoteInternal(
    bytes32 _proposalId,
    address _voter
  )
  internal
  {
    Proposal storage proposal = proposals[_proposalId];
    Voter memory voter = proposal.voters[_voter];
    proposal.votes[voter.vote] = (proposal.votes[voter.vote]).sub(voter.reputation);
    proposal.totalVotes = (proposal.totalVotes).sub(voter.reputation);
    delete proposal.voters[_voter];
    emit CancelVoting(_proposalId, organization, _voter);
  }

  function deleteProposal(
    bytes32 _proposalId
  )
  internal
  {
    Proposal storage proposal = proposals[_proposalId];
    for (uint256 cnt = 0; cnt <= proposal.numOfChoices; cnt++) {
      delete proposal.votes[cnt];
    }
    delete proposals[_proposalId];
  }

  /**
    * @dev execute check if the proposal has been decided, and if so, execute the proposal
    * @param _proposalId the id of the proposal
    * @return bool true - the proposal has been executed
    *              false - otherwise.
    */
  function _execute(
    bytes32 _proposalId
  )
  internal
  votable(_proposalId)
  returns(bool)
  {
    Proposal storage proposal = proposals[_proposalId];
    uint256 totalReputation =
    IVotingMachineCallbacks(callbacks).getTotalSupply(_proposalId);
    uint256 percReq = parameters.percReq;

    // Check if someone crossed the bar:
    for (uint256 cnt = 0; cnt <= proposal.numOfChoices; cnt++) {
      if (proposal.votes[cnt] > (totalReputation/100)*percReq) {
        deleteProposal(_proposalId);
        emit ExecuteProposal(_proposalId, organization, cnt, totalReputation);
        return ProposalExecuteInterface(callbacks).executeProposal(_proposalId, int(cnt));
      }
    }

    return false;
  }

  /**
    * @dev Vote for a proposal, if the voter already voted, cancel the last vote and set a new one instead
    * @param _proposalId id of the proposal
    * @param _voter used in case the vote is cast for someone else
    * @param _vote a value between 0 to and the proposal's number of choices.
    * @return true in case of proposal execution otherwise false
    * throws if proposal is not open or if it has been executed
    * NB: executes the proposal if a decision has been reached
    */
  function internalVote(
    bytes32 _proposalId,
    address _voter,
    uint256 _vote,
    uint256 _rep
  )
  internal
  returns(bool)
  {
    Proposal storage proposal = proposals[_proposalId];

    // Check valid vote:
    require(_vote <= proposal.numOfChoices, "vote is out of range");

    // Check voter has enough reputation:
    uint256 reputation = IVotingMachineCallbacks(callbacks).reputationOf(_voter, _proposalId);
    require(reputation > 0, "_voter must have reputation");
    require(reputation >= _rep, "cannot vote with more reputation voter has");
    uint256 rep = _rep;
    if (rep == 0) {
      rep = reputation;
    }

    // If this voter has already voted, first cancel the vote:
    if (proposal.voters[_voter].reputation != 0) {
      cancelVoteInternal(_proposalId, _voter);
    }

    // The voting itself:
    proposal.votes[_vote] = rep.add(proposal.votes[_vote]);
    proposal.totalVotes = rep.add(proposal.totalVotes);
    proposal.voters[_voter] = Voter({
      reputation: rep,
      vote: _vote
    });

    // Event:
    emit VoteProposal(_proposalId, organization, _voter, _vote, rep);
    emit AVVoteProposal(_proposalId, (_voter != msg.sender));

    // execute the proposal if this vote was decisive:
    return _execute(_proposalId);
  }
}
